// Package grpcinstrument helps instrumenting gRPC servers.
//
// This package defines the Instrumentator interface which applications must
// implement to integrate with whatever instrumentation infrastructure is at
// their disposale. This includes, but is not limited to, logging and metrics.
//
// It also includes the `protoc-gen-grpcinstrument` Protocol Buffer compiler
// plugin for generating code that wraps and instruments gRPC server
// implementations.
package grpcinstrument

import (
	"time"

	"go.pedge.io/proto/time"
)

// Instrumentator is the interface that servers must implement in order to
// integrate with the code generated by the protoc plugin plugin.
type Instrumentator interface {
	Init() error
	Instrument(*Call)
}

// Logger is the interface for logging RPC calls.
type Logger interface {
	Init() error
	Log(*Call)
}

// Measurer is the interface for measuring (error rate, latency, ...) RPC calls.
type Measurer interface {
	Init() error
	Measure(*Call)
}

// NewLoggerMeasurer constructs an implementation of the Instrumentator interface
// for its most common use case, logging and collecting metrics about RPC calls.
func NewLoggerMeasurer(logger Logger, measurer Measurer) Instrumentator {
	return newLoggerMeasurer(logger, measurer)
}

// NewCall instantiates a new Call struct and sets the duration field to the
// elapsed time since `start`.
func NewCall(
	serviceName string,
	methodName string,
	inputType string,
	outputType string,
	err error,
	start time.Time,
) *Call {
	call := &Call{
		Service:  serviceName,
		Method:   methodName,
		Input:    &Input{Type: inputType},
		Output:   &Output{Type: outputType},
		Duration: prototime.DurationToProto(time.Since(start)),
	}
	if err != nil {
		call.Error = &Error{Message: err.Error()}
	}
	return call
}

// Instrument is the method used by the code generated by the protoc plugin
// included in this package.
func Instrument(
	instrumentator Instrumentator,
	serviceName string,
	methodName string,
	inputType string,
	outputType string,
	err error,
	start time.Time,
) {
	instrumentator.Instrument(NewCall(
		serviceName,
		methodName,
		inputType,
		outputType,
		err,
		start,
	))
}

// IsError returns true if the server responded to the request with an error,
// false otherwise.
func (c *Call) IsError() bool {
	return c.Error != nil
}
